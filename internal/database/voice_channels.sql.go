// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: voice_channels.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createVoiceChannel = `-- name: CreateVoiceChannel :one
INSERT INTO voice_channels (
        id,
        owner_id,
        server_id,
        language_id,
        channel_name,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, owner_id, server_id, language_id, channel_name, last_active, is_locked, created_at, updated_at
`

type CreateVoiceChannelParams struct {
	ID          uuid.UUID `json:"id"`
	OwnerID     uuid.UUID `json:"owner_id"`
	ServerID    uuid.UUID `json:"server_id"`
	LanguageID  uuid.UUID `json:"language_id"`
	ChannelName string    `json:"channel_name"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) CreateVoiceChannel(ctx context.Context, arg CreateVoiceChannelParams) (VoiceChannel, error) {
	row := q.db.QueryRowContext(ctx, createVoiceChannel,
		arg.ID,
		arg.OwnerID,
		arg.ServerID,
		arg.LanguageID,
		arg.ChannelName,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i VoiceChannel
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ServerID,
		&i.LanguageID,
		&i.ChannelName,
		&i.LastActive,
		&i.IsLocked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getServerVoiceChannels = `-- name: GetServerVoiceChannels :many
SELECT 
    vc.id AS channel_id,
    vc.owner_id,
    vc.server_id,
    vc.language_id,
    vc.channel_name,
    vc.last_active,
    vc.is_locked,
    vc.created_at AS channel_created_at,
    vc.updated_at AS channel_updated_at,
    COALESCE(json_agg(
        json_build_object(
            'user_id', vcm.user_id,
            'handle', u.handle
        ) 
    ) FILTER (WHERE vcm.user_id IS NOT NULL), '[]'::json) AS members
FROM 
    voice_channels vc
LEFT JOIN 
    voice_channel_members vcm ON vc.id = vcm.channel_id
LEFT JOIN
    users u ON vcm.user_id = u.id
WHERE 
    vc.server_id = $1
GROUP BY
    vc.id
ORDER BY 
    vc.created_at DESC
`

type GetServerVoiceChannelsRow struct {
	ChannelID        uuid.UUID    `json:"channel_id"`
	OwnerID          uuid.UUID    `json:"owner_id"`
	ServerID         uuid.UUID    `json:"server_id"`
	LanguageID       uuid.UUID    `json:"language_id"`
	ChannelName      string       `json:"channel_name"`
	LastActive       sql.NullTime `json:"last_active"`
	IsLocked         sql.NullBool `json:"is_locked"`
	ChannelCreatedAt time.Time    `json:"channel_created_at"`
	ChannelUpdatedAt time.Time    `json:"channel_updated_at"`
	Members          interface{}  `json:"members"`
}

func (q *Queries) GetServerVoiceChannels(ctx context.Context, serverID uuid.UUID) ([]GetServerVoiceChannelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getServerVoiceChannels, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServerVoiceChannelsRow
	for rows.Next() {
		var i GetServerVoiceChannelsRow
		if err := rows.Scan(
			&i.ChannelID,
			&i.OwnerID,
			&i.ServerID,
			&i.LanguageID,
			&i.ChannelName,
			&i.LastActive,
			&i.IsLocked,
			&i.ChannelCreatedAt,
			&i.ChannelUpdatedAt,
			&i.Members,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinVoiceChannel = `-- name: JoinVoiceChannel :one
INSERT INTO voice_channel_members (
    user_id,
    channel_id,
    server_id
    )
VALUES ($1, $2, $3)
RETURNING user_id, channel_id, server_id
`

type JoinVoiceChannelParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ChannelID uuid.UUID `json:"channel_id"`
	ServerID  uuid.UUID `json:"server_id"`
}

func (q *Queries) JoinVoiceChannel(ctx context.Context, arg JoinVoiceChannelParams) (VoiceChannelMember, error) {
	row := q.db.QueryRowContext(ctx, joinVoiceChannel, arg.UserID, arg.ChannelID, arg.ServerID)
	var i VoiceChannelMember
	err := row.Scan(&i.UserID, &i.ChannelID, &i.ServerID)
	return i, err
}

const leaveVoiceChannelByUser = `-- name: LeaveVoiceChannelByUser :exec
DELETE FROM voice_channel_members
WHERE user_id = $1
`

func (q *Queries) LeaveVoiceChannelByUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, leaveVoiceChannelByUser, userID)
	return err
}
